<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-218112214 { color: #DA70D6; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta')
1=[()]
2=[()]
3=[(deduction ( Q (STV 1 0.5)) ( Q (STV 1 0.5)) ( R (STV 1 0.1)) (idi_induction ( (Q 42) (Bl False)) ( (Q 42) (Bl False)) (idi_axiom) ( 42 Empty)) ( ( Q R) (STV 1 0.5))), (deduction ( P (STV 1 0.1)) ( Q (STV 1 0.5)) ( R (STV 1 0.1)) (idi_induction ( (P 42) (Bl True)) ( (Q 42) (Bl False)) (idi_axiom) ( 42 Empty)) ( ( Q R) (STV 1 0.5)))]
4=0.38user 0.01system 0:00.40elapsed 100%CPU (0avgtext+0avgdata 35000maxresident)k
4=0inputs+0outputs (0major+3934minor)pagefaults 0swaps
:- dynamic file_answers/3.

file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta', 1, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta', 2, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta', 3, [[deduction, [, 'Q', ['STV', 1, 0.5]], [, 'Q', ['STV', 1, 0.5]], [, 'R', ['STV', 1, 0.1]], [idi_induction, [, ['Q', 42], ['Bl', 'False']], [, ['Q', 42], ['Bl', 'False']], [idi_axiom], [, 42, 'Empty']], [, [, 'Q', 'R'], ['STV', 1, 0.5]]], [deduction, [, 'P', ['STV', 1, 0.1]], [, 'Q', ['STV', 1, 0.5]], [, 'R', ['STV', 1, 0.1]], [idi_induction, [, ['P', 42], ['Bl', 'True']], [, ['Q', 42], ['Bl', 'False']], [idi_axiom], [, 42, 'Empty']], [, [, 'Q', 'R'], ['STV', 1, 0.5]]]]).

;; DeductionMatch and ImplicationDirectionIntroductionMatch
<span class="ansi38-013099040">!(import! &self ImplicationDirectIntroductionMatch.metta)

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','ImplicationDirectIntroductionMatch.metta'],OUT).

</span>    -->(0,eval('&self',['import!','&self','ImplicationDirectIntroductionMatch.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/ImplicationDirectIntroductionMatch.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/ImplicationDirectIntroductionMatch.metta')
;;; MeTTa port of the Implication Direct Introduction PLN rule, using
;;; the match operator.
;;;
;;; (P a)  p
;;; ...
;;; (P a)  p
;;; (Q a)  q
;;; ...
;;; (Q a)  q
;;; 
;;; PQ  tv
;;;
;;; where p (resp. q) are of boolean type representing whether (P a)
;;; (resp. (Q a)) has been observed as True or False, and tv
;;; represents the resulting truth value of the conclusion.
;;; Import modules
<span class="ansi38-013099040">!(import! &self "../common/OrderedSet.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../common/OrderedSet.metta'],OUT).

</span>    -->(1,eval('&self',['import!','&self','../common/OrderedSet.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/OrderedSet.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/OrderedSet.metta')
;;; Import modules
<span class="ansi38-013099040">!(import! &self Num.metta)

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','Num.metta'],OUT).

</span>    -->(2,eval('&self',['import!','&self','Num.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta')
;;; Definition of a set data structure.  Under the hood it is a sorted
;;; list without duplicates, thus called OrderedSet.  For now its
;;; constructor :: is unconstrained, meaning it does not guaranty that
;;; the constructed OrderedSet are sorted and without duplicates.
;;; Rather this is delegated to the insert function defined below.  In
;;; order to guaranty that it is sorted without duplicates, the
;;; constructor :: would need to take an additional argument encoding a
;;; proof that the element to prepend is less than the head of the set
;;; to be prepended to.
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,X,Y],[if,[>,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,X,Y],[if,[<,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,X,L,U],[max,L,[min,U,X]]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,X],[if,[<,X,0],[*,-1,X],X]])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon]])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S',K]],[+,1,[fromNat,K]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, , for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  ( $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  ( Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',['S',X],['S',Y]],['',X,Y]])
</span><span class="ansi38-255165000">(= 
  ( 
    (S $X) 
    (S $Y)) 
  ( $X $Y))
</span>

;;; Overload  for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',X,Y],[<,X,Y]])
</span><span class="ansi38-255165000">(= 
  ( $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,N],[fromNat,[fromNumber,N]]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool',X],[<,0,X]])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than  as it is a type, not an operator.  Inhabitants of ( x y)
;;; are proofs that x  y == True.  For now  is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(:  
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['\x8D\\x83\','Z',['S',K]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    ( Z 
      (S $K))))
</span>

;;; If x  y then (S x)  (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['\x8D\\x83\',X,Y],['\x8D\\x83\',['S',X],['S',Y]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      ( $X $Y) 
      ( 
        (S $X) 
        (S $Y)))))
</span>

    <--(2,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'OrderedSet',[->,A,'Type']])
</span><span class="ansi38-255165000">(: OrderedSet 
  (-> $A Type))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x88\\x85\',['OrderedSet',A]])
</span><span class="ansi38-255165000">(:  
  (OrderedSet $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,::,[->,A,['OrderedSet',A],['OrderedSet',A]]])
</span><span class="ansi38-255165000">(: :: 
  (-> $A 
    (OrderedSet $A) 
    (OrderedSet $A)))
</span>

;;; Check if an element is in a set.  TODO: optimize assuming it is
;;; ordered.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,elem,[->,A,['OrderedSet',A],'Bool']])
</span><span class="ansi38-255165000">(: elem 
  (-> $A 
    (OrderedSet $A) Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[elem,X,'\x88\\x85\'],'False'])
</span><span class="ansi38-255165000">(= 
  (elem $X ) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[elem,X,[::,H,T]],[if,[==,X,H],'True',[elem,X,T]]])
</span><span class="ansi38-255165000">(= 
  (elem $X 
    (:: $H $T)) 
  (if 
    (== $X $H) True 
    (elem $X $T)))
</span>

;;; Insert an element into a set.  Only insert if the element is not
;;; already in the set as to produce an ordered set.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,insert,[->,A,['OrderedSet',A],['OrderedSet',A]]])
</span><span class="ansi38-255165000">(: insert 
  (-> $A 
    (OrderedSet $A) 
    (OrderedSet $A)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[insert,X,'\x88\\x85\'],[::,X,'\x88\\x85\']])
</span><span class="ansi38-255165000">(= 
  (insert $X ) 
  (:: $X ))
</span>

;; Base case
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[insert,X,[::,H,T]],[if,[==,X,H],[::,H,T],[if,['',X,H],[::,X,[::,H,T]],[::,H,[insert,X,T]]]]])
</span><span class="ansi38-255165000">(= 
  (insert $X 
    (:: $H $T)) 
  (if 
    (== $X $H) 
    (:: $H $T) 
    (if 
      ( $X $H) 
      (:: $X 
        (:: $H $T)) 
      (:: $H 
        (insert $X $T)))))
</span>

    <--(1,retval('Empty'))
Last Result(2): <span class="ansi33">Empty

</span>;; Recursive step
;; Present, no need to insert
;; Use generic <
;; Safely insert since $x < $h
;; Recursive call
<span class="ansi38-013099040">!(import! &self "../common/truthvalue/EvidentialTruthValue.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../common/truthvalue/EvidentialTruthValue.metta'],OUT).

</span>    -->(3,eval('&self',['import!','&self','../common/truthvalue/EvidentialTruthValue.metta'],RET),depth(0))
%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/EvidentialTruthValue.metta:1 
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/EvidentialTruthValue.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/EvidentialTruthValue.metta')
;;; Evidential truth value type. Represent a truth value alongside its
;;; evidence.
<span class="ansi38-013099040">!(import! &self TruthValue.metta)

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','TruthValue.metta'],OUT).

</span>    -->(4,eval('&self',['import!','&self','TruthValue.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta')
;;; Truth value type definition
;;; Import modules
<span class="ansi38-013099040">!(import! &self "../Num.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../Num.metta'],OUT).

</span>    -->(5,eval('&self',['import!','&self','../Num.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta')
;;;;;;;;;;;
;;; Type ;;
;;;;;;;;;;;
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,X,Y],[if,[>,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,X,Y],[if,[<,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,X,L,U],[max,L,[min,U,X]]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,X],[if,[<,X,0],[*,-1,X],X]])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon]])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S',K]],[+,1,[fromNat,K]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, , for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  ( $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  ( Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',['S',X],['S',Y]],['',X,Y]])
</span><span class="ansi38-255165000">(= 
  ( 
    (S $X) 
    (S $Y)) 
  ( $X $Y))
</span>

;;; Overload  for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',X,Y],[<,X,Y]])
</span><span class="ansi38-255165000">(= 
  ( $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,N],[fromNat,[fromNumber,N]]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool',X],[<,0,X]])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than  as it is a type, not an operator.  Inhabitants of ( x y)
;;; are proofs that x  y == True.  For now  is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(:  
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['\x8D\\x83\','Z',['S',K]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    ( Z 
      (S $K))))
</span>

;;; If x  y then (S x)  (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['\x8D\\x83\',X,Y],['\x8D\\x83\',['S',X],['S',Y]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      ( $X $Y) 
      ( 
        (S $X) 
        (S $Y)))))
</span>

    <--(5,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'TruthValue','Type'])
</span><span class="ansi38-255165000">(: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;;
;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;
;;; Boolean TV constructor
;;; TODO: alternatively we could have (:  TruthValue) and (:  TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Bl',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">(: Bl 
  (-> Bool TruthValue))
</span>

;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Pr',[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">(: Pr 
  (-> Number TruthValue))
</span>

;;; Simple Truth Value.  A Second order probability TV constructor,
;;; i.e. probability and confidence.  The probability is in fact the
;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'STV',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">(: STV 
  (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;;
;;; Constants ;;
;;;;;;;;;;;;;;;;
;;; For now the underlying beta distributions have a Jeffreys prior,
;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-alpha',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-alpha 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-alpha'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-alpha) 0.5)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-beta',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-beta 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-beta'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-beta) 0.5)
</span>

;;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,lookahead,[->,'Number']])
</span><span class="ansi38-255165000">(: lookahead 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[lookahead],1.0])
</span><span class="ansi38-255165000">(= 
  (lookahead) 1.0)
</span>

;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'max-count',[->,'Number']])
</span><span class="ansi38-255165000">(: max-count 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['max-count'],1000000000.0])
</span><span class="ansi38-255165000">(= 
  (max-count) 1000000000.0)
</span>

;;;;;;;;;;;;;;
;;; Methods ;;
;;;;;;;;;;;;;;
;;; Convert count to confidence using the formula
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'count->confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: count->confidence 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['count->confidence',Cnt],[/,Cnt,[+,Cnt,[lookahead]]]])
</span><span class="ansi38-255165000">(= 
  (count->confidence $Cnt) 
  (/ $Cnt 
    (+ $Cnt 
      (lookahead))))
</span>

;;; Convert confidence to count using the formula
;;;
;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'confidence->count',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: confidence->count 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['confidence->count',Conf],[if,[approxEq,1.0,Conf,1.0e-9],['max-count'],[/,[*,Conf,[lookahead]],[-,1.0,Conf]]]])
</span><span class="ansi38-255165000">(= 
  (confidence->count $Conf) 
  (if 
    (approxEq 1.0 $Conf 1.0e-9) 
    (max-count) 
    (/ 
      (* $Conf 
        (lookahead)) 
      (- 1.0 $Conf))))
</span>

;;; Increment the negative count of a given truth value, by
;;; incrementing its total count without incrementing the positive
;;; count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-neg-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-neg-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-neg-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,Pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]]])
</span><span class="ansi38-255165000">(= 
  (inc-neg-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      (/ $Pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Increment the positive count of a given truth value, by
;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-pos-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-pos-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-pos-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_pos_cnt,[+,Pos_cnt,1]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,New_pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]]])
</span><span class="ansi38-255165000">(= 
  (inc-pos-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_pos_cnt 
        (+ $Pos_cnt 1)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      (/ $New_pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Return the first order probability mode of the second order
;;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mode,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mode 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Pr',Pr]],Pr])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['STV',Pr,_]],Pr])
</span><span class="ansi38-255165000">(= 
  (mode 
    (STV $Pr $_)) $Pr)
</span>

;;; Return the total count of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the count
;;; is assumed to be a very large number (cause +inf does not seem to
;;; be supported at the moment).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Bl',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Bl $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Pr',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Pr $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['STV',_,Conf]],['confidence->count',Conf]])
</span><span class="ansi38-255165000">(= 
  (count 
    (STV $_ $Conf)) 
  (confidence->count $Conf))
</span>

;;; Return the confidence of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, the formula to convert a count
;;; into confidence is as follows
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,confidence,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: confidence 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Bl',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Bl $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Pr',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Pr $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['STV',_,Conf]],Conf])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (STV $_ $Conf)) $Conf)
</span>

;;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'pos-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: pos-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['pos-count',Tv],[*,[mode,Tv],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (pos-count $Tv) 
  (* 
    (mode $Tv) 
    (count $Tv)))
</span>

;;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'neg-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: neg-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['neg-count',Tv],[*,[-,1,[mode,Tv]],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (neg-count $Tv) 
  (* 
    (- 1 
      (mode $Tv)) 
    (count $Tv)))
</span>

;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-alpha',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-alpha 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-alpha',Tv],[+,['prior-alpha'],['pos-count',Tv]]])
</span><span class="ansi38-255165000">(= 
  (post-alpha $Tv) 
  (+ 
    (prior-alpha) 
    (pos-count $Tv)))
</span>

;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-beta',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-beta 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-beta',Tv],[+,['prior-beta'],['neg-count',Tv]]])
</span><span class="ansi38-255165000">(= 
  (post-beta $Tv) 
  (+ 
    (prior-beta) 
    (neg-count $Tv)))
</span>

;;; Return the first order probability mean of the second order
;;; distribution associated to a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mean,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mean 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Pr',Pr]],Pr])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['STV',Pr,Conf]],['let*',[[A,['post-alpha',['STV',Pr,Conf]]],[B,['post-beta',['STV',Pr,Conf]]]],[/,A,[+,A,B]]]])
</span><span class="ansi38-255165000">(= 
  (mean 
    (STV $Pr $Conf)) 
  (let* 
    ( ($A 
        (post-alpha 
          (STV $Pr $Conf))) 
      ($B 
        (post-beta 
          (STV $Pr $Conf)))) 
    (/ $A 
      (+ $A $B))))
</span>

    <--(4,retval('Empty'))
Last Result(2): <span class="ansi33">Empty

</span><span class="ansi38-013099040">!(import! &self "../OrderedSet.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../OrderedSet.metta'],OUT).

</span>    -->(6,eval('&self',['import!','&self','../OrderedSet.metta'],RET),depth(0))
%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/EvidentialTruthValue.metta:177 
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/OrderedSet.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/OrderedSet.metta')
;;;;;;;;;;;
;;; Type ;;
;;;;;;;;;;;
;;; Import modules
<span class="ansi38-013099040">!(import! &self Num.metta)

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','Num.metta'],OUT).

</span>    -->(7,eval('&self',['import!','&self','Num.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta')
;;; Definition of a set data structure.  Under the hood it is a sorted
;;; list without duplicates, thus called OrderedSet.  For now its
;;; constructor :: is unconstrained, meaning it does not guaranty that
;;; the constructed OrderedSet are sorted and without duplicates.
;;; Rather this is delegated to the insert function defined below.  In
;;; order to guaranty that it is sorted without duplicates, the
;;; constructor :: would need to take an additional argument encoding a
;;; proof that the element to prepend is less than the head of the set
;;; to be prepended to.
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,X,Y],[if,[>,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,X,Y],[if,[<,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,X,L,U],[max,L,[min,U,X]]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,X],[if,[<,X,0],[*,-1,X],X]])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon]])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S',K]],[+,1,[fromNat,K]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, , for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  ( $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  ( Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',['S',X],['S',Y]],['',X,Y]])
</span><span class="ansi38-255165000">(= 
  ( 
    (S $X) 
    (S $Y)) 
  ( $X $Y))
</span>

;;; Overload  for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',X,Y],[<,X,Y]])
</span><span class="ansi38-255165000">(= 
  ( $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,N],[fromNat,[fromNumber,N]]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool',X],[<,0,X]])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than  as it is a type, not an operator.  Inhabitants of ( x y)
;;; are proofs that x  y == True.  For now  is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(:  
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['\x8D\\x83\','Z',['S',K]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    ( Z 
      (S $K))))
</span>

;;; If x  y then (S x)  (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['\x8D\\x83\',X,Y],['\x8D\\x83\',['S',X],['S',Y]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      ( $X $Y) 
      ( 
        (S $X) 
        (S $Y)))))
</span>

    <--(7,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'OrderedSet',[->,A,'Type']])
</span><span class="ansi38-255165000">(: OrderedSet 
  (-> $A Type))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x88\\x85\',['OrderedSet',A]])
</span><span class="ansi38-255165000">(:  
  (OrderedSet $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,::,[->,A,['OrderedSet',A],['OrderedSet',A]]])
</span><span class="ansi38-255165000">(: :: 
  (-> $A 
    (OrderedSet $A) 
    (OrderedSet $A)))
</span>

;;; Check if an element is in a set.  TODO: optimize assuming it is
;;; ordered.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,elem,[->,A,['OrderedSet',A],'Bool']])
</span><span class="ansi38-255165000">(: elem 
  (-> $A 
    (OrderedSet $A) Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[elem,X,'\x88\\x85\'],'False'])
</span><span class="ansi38-255165000">(= 
  (elem $X ) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[elem,X,[::,H,T]],[if,[==,X,H],'True',[elem,X,T]]])
</span><span class="ansi38-255165000">(= 
  (elem $X 
    (:: $H $T)) 
  (if 
    (== $X $H) True 
    (elem $X $T)))
</span>

;;; Insert an element into a set.  Only insert if the element is not
;;; already in the set as to produce an ordered set.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,insert,[->,A,['OrderedSet',A],['OrderedSet',A]]])
</span><span class="ansi38-255165000">(: insert 
  (-> $A 
    (OrderedSet $A) 
    (OrderedSet $A)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[insert,X,'\x88\\x85\'],[::,X,'\x88\\x85\']])
</span><span class="ansi38-255165000">(= 
  (insert $X ) 
  (:: $X ))
</span>

;; Base case
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[insert,X,[::,H,T]],[if,[==,X,H],[::,H,T],[if,['',X,H],[::,X,[::,H,T]],[::,H,[insert,X,T]]]]])
</span><span class="ansi38-255165000">(= 
  (insert $X 
    (:: $H $T)) 
  (if 
    (== $X $H) 
    (:: $H $T) 
    (if 
      ( $X $H) 
      (:: $X 
        (:: $H $T)) 
      (:: $H 
        (insert $X $T)))))
</span>

    <--(6,retval('Empty'))
Last Result(2): <span class="ansi33">Empty

</span>;; Recursive step
;; Present, no need to insert
;; Use generic <
;; Safely insert since $x < $h
;; Recursive call
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'EvidentialTruthValue','Type'])
</span><span class="ansi38-255165000">(: EvidentialTruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;;
;;; Constructor ;;
;;;;;;;;;;;;;;;;;;;
;;; Takes an evidence set ascribed to a truth value to form an
;;; evidential truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'ETV',[->,['OrderedSet',A],'TruthValue','EvidentialTruthValue']])
</span><span class="ansi38-255165000">(: ETV 
  (-> 
    (OrderedSet $A) TruthValue EvidentialTruthValue))
</span>

;;;;;;;;;;;;;;
;;; Methods ;;
;;;;;;;;;;;;;;
;;; Access the truth value of an evidential truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,tv,[->,'EvidentialTruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: tv 
  (-> EvidentialTruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[tv,['ETV',Ev,Tv]],Tv])
</span><span class="ansi38-255165000">(= 
  (tv 
    (ETV $Ev $Tv)) $Tv)
</span>

;;; Return the first order probability mode of the second order
;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mode,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: mode 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['ETV',Ev,Tv]],[mode,Tv]])
</span><span class="ansi38-255165000">(= 
  (mode 
    (ETV $Ev $Tv)) 
  (mode $Tv))
</span>

;;; Return the total count of an evidential truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,count,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: count 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['ETV',Ev,Tv]],[count,Tv]])
</span><span class="ansi38-255165000">(= 
  (count 
    (ETV $Ev $Tv)) 
  (count $Tv))
</span>

;;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,pos_count,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: pos_count 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[pos_count,['ETV',Ev,Tv]],[*,[mode,Tv],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (pos_count 
    (ETV $Ev $Tv)) 
  (* 
    (mode $Tv) 
    (count $Tv)))
</span>

;;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,neg_count,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: neg_count 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[neg_count,['ETV',Ev,Tv]],[*,[-,1,[mode,Tv]],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (neg_count 
    (ETV $Ev $Tv)) 
  (* 
    (- 1 
      (mode $Tv)) 
    (count $Tv)))
</span>

;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,post_alpha,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: post_alpha 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[post_alpha,['ETV',Ev,Tv]],[+,[prior_alpha],[pos_count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (post_alpha 
    (ETV $Ev $Tv)) 
  (+ 
    (prior_alpha) 
    (pos_count $Tv)))
</span>

;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,post_beta,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: post_beta 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[post_beta,['ETV',Ev,Tv]],[+,[prior_beta],[neg_count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (post_beta 
    (ETV $Ev $Tv)) 
  (+ 
    (prior_beta) 
    (neg_count $Tv)))
</span>

;;; Return the first order probability mean of the second order
;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mean,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: mean 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['ETV',Ev,Tv]],[mean,Tv]])
</span><span class="ansi38-255165000">(= 
  (mean 
    (ETV $Ev $Tv)) 
  (mean $Tv))
</span>

;;; Return the confidence of an evidential truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,confidence,[->,'EvidentialTruthValue','Number']])
</span><span class="ansi38-255165000">(: confidence 
  (-> EvidentialTruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['ETV',Ev,Tv]],[confidence,Tv]])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (ETV $Ev $Tv)) 
  (confidence $Tv))
</span>

    <--(3,retval('Empty'))
Last Result(3): <span class="ansi33">Empty

</span><span class="ansi38-013099040">!(import! &self "../common/formula/ImplicationDirectIntroductionFormula.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../common/formula/ImplicationDirectIntroductionFormula.metta'],OUT).

</span>    -->(8,eval('&self',['import!','&self','../common/formula/ImplicationDirectIntroductionFormula.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/formula/ImplicationDirectIntroductionFormula.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/formula/ImplicationDirectIntroductionFormula.metta')
;;;;;;;;;;;;;;;;;;;;;;
;;; Rule Definition ;;
;;;;;;;;;;;;;;;;;;;;;;
;;; To deal with an abritrary number of pieces of evidence the rule is
;;; defined inductively.
;;; Base case (axiomatic rule):
;;;
;;; pq  (ETV Empty (STV 1 0))
;;;
;;; Directly present in the atomspace.
;;; Formula for the inductive Implication Direct Introduction rule.
;;; Import modules
<span class="ansi38-013099040">!(import! &self "../truthvalue/TruthValue.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../truthvalue/TruthValue.metta'],OUT).

</span>    -->(9,eval('&self',['import!','&self','../truthvalue/TruthValue.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta')
;;; Alternate implication direct introduction formula assuming Boolean
;;; evidence.  Base case, meaning there is only one piece of evidence.
;;; Truth value type definition
;;; Import modules
<span class="ansi38-013099040">!(import! &self "../Num.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../Num.metta'],OUT).

</span>    -->(10,eval('&self',['import!','&self','../Num.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta')
;;;;;;;;;;;
;;; Type ;;
;;;;;;;;;;;
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,X,Y],[if,[>,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,X,Y],[if,[<,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,X,L,U],[max,L,[min,U,X]]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,X],[if,[<,X,0],[*,-1,X],X]])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon]])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S',K]],[+,1,[fromNat,K]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, , for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  ( $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  ( Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',['S',X],['S',Y]],['',X,Y]])
</span><span class="ansi38-255165000">(= 
  ( 
    (S $X) 
    (S $Y)) 
  ( $X $Y))
</span>

;;; Overload  for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',X,Y],[<,X,Y]])
</span><span class="ansi38-255165000">(= 
  ( $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,N],[fromNat,[fromNumber,N]]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool',X],[<,0,X]])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than  as it is a type, not an operator.  Inhabitants of ( x y)
;;; are proofs that x  y == True.  For now  is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(:  
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['\x8D\\x83\','Z',['S',K]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    ( Z 
      (S $K))))
</span>

;;; If x  y then (S x)  (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['\x8D\\x83\',X,Y],['\x8D\\x83\',['S',X],['S',Y]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      ( $X $Y) 
      ( 
        (S $X) 
        (S $Y)))))
</span>

    <--(10,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'TruthValue','Type'])
</span><span class="ansi38-255165000">(: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;;
;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;
;;; Boolean TV constructor
;;; TODO: alternatively we could have (:  TruthValue) and (:  TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Bl',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">(: Bl 
  (-> Bool TruthValue))
</span>

;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Pr',[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">(: Pr 
  (-> Number TruthValue))
</span>

;;; Simple Truth Value.  A Second order probability TV constructor,
;;; i.e. probability and confidence.  The probability is in fact the
;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'STV',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">(: STV 
  (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;;
;;; Constants ;;
;;;;;;;;;;;;;;;;
;;; For now the underlying beta distributions have a Jeffreys prior,
;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-alpha',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-alpha 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-alpha'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-alpha) 0.5)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-beta',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-beta 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-beta'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-beta) 0.5)
</span>

;;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,lookahead,[->,'Number']])
</span><span class="ansi38-255165000">(: lookahead 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[lookahead],1.0])
</span><span class="ansi38-255165000">(= 
  (lookahead) 1.0)
</span>

;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'max-count',[->,'Number']])
</span><span class="ansi38-255165000">(: max-count 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['max-count'],1000000000.0])
</span><span class="ansi38-255165000">(= 
  (max-count) 1000000000.0)
</span>

;;;;;;;;;;;;;;
;;; Methods ;;
;;;;;;;;;;;;;;
;;; Convert count to confidence using the formula
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'count->confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: count->confidence 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['count->confidence',Cnt],[/,Cnt,[+,Cnt,[lookahead]]]])
</span><span class="ansi38-255165000">(= 
  (count->confidence $Cnt) 
  (/ $Cnt 
    (+ $Cnt 
      (lookahead))))
</span>

;;; Convert confidence to count using the formula
;;;
;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'confidence->count',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: confidence->count 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['confidence->count',Conf],[if,[approxEq,1.0,Conf,1.0e-9],['max-count'],[/,[*,Conf,[lookahead]],[-,1.0,Conf]]]])
</span><span class="ansi38-255165000">(= 
  (confidence->count $Conf) 
  (if 
    (approxEq 1.0 $Conf 1.0e-9) 
    (max-count) 
    (/ 
      (* $Conf 
        (lookahead)) 
      (- 1.0 $Conf))))
</span>

;;; Increment the negative count of a given truth value, by
;;; incrementing its total count without incrementing the positive
;;; count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-neg-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-neg-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-neg-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,Pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]]])
</span><span class="ansi38-255165000">(= 
  (inc-neg-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      (/ $Pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Increment the positive count of a given truth value, by
;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-pos-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-pos-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-pos-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_pos_cnt,[+,Pos_cnt,1]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,New_pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]]])
</span><span class="ansi38-255165000">(= 
  (inc-pos-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_pos_cnt 
        (+ $Pos_cnt 1)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      (/ $New_pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Return the first order probability mode of the second order
;;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mode,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mode 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Pr',Pr]],Pr])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['STV',Pr,_]],Pr])
</span><span class="ansi38-255165000">(= 
  (mode 
    (STV $Pr $_)) $Pr)
</span>

;;; Return the total count of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the count
;;; is assumed to be a very large number (cause +inf does not seem to
;;; be supported at the moment).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Bl',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Bl $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Pr',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Pr $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['STV',_,Conf]],['confidence->count',Conf]])
</span><span class="ansi38-255165000">(= 
  (count 
    (STV $_ $Conf)) 
  (confidence->count $Conf))
</span>

;;; Return the confidence of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, the formula to convert a count
;;; into confidence is as follows
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,confidence,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: confidence 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Bl',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Bl $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Pr',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Pr $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['STV',_,Conf]],Conf])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (STV $_ $Conf)) $Conf)
</span>

;;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'pos-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: pos-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['pos-count',Tv],[*,[mode,Tv],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (pos-count $Tv) 
  (* 
    (mode $Tv) 
    (count $Tv)))
</span>

;;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'neg-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: neg-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['neg-count',Tv],[*,[-,1,[mode,Tv]],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (neg-count $Tv) 
  (* 
    (- 1 
      (mode $Tv)) 
    (count $Tv)))
</span>

;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-alpha',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-alpha 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-alpha',Tv],[+,['prior-alpha'],['pos-count',Tv]]])
</span><span class="ansi38-255165000">(= 
  (post-alpha $Tv) 
  (+ 
    (prior-alpha) 
    (pos-count $Tv)))
</span>

;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-beta',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-beta 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-beta',Tv],[+,['prior-beta'],['neg-count',Tv]]])
</span><span class="ansi38-255165000">(= 
  (post-beta $Tv) 
  (+ 
    (prior-beta) 
    (neg-count $Tv)))
</span>

;;; Return the first order probability mean of the second order
;;; distribution associated to a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mean,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mean 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Pr',Pr]],Pr])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['STV',Pr,Conf]],['let*',[[A,['post-alpha',['STV',Pr,Conf]]],[B,['post-beta',['STV',Pr,Conf]]]],[/,A,[+,A,B]]]])
</span><span class="ansi38-255165000">(= 
  (mean 
    (STV $Pr $Conf)) 
  (let* 
    ( ($A 
        (post-alpha 
          (STV $Pr $Conf))) 
      ($B 
        (post-beta 
          (STV $Pr $Conf)))) 
    (/ $A 
      (+ $A $B))))
</span>

    <--(9,retval('Empty'))
Last Result(2): <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'direct-introduction-base-formula',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">(: direct-introduction-base-formula 
  (-> Bool TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['direct-introduction-base-formula',Qa],['STV',['bool->number',Qa],['count->confidence',1]]])
</span><span class="ansi38-255165000">(= 
  (direct-introduction-base-formula $Qa) 
  (STV 
    (bool->number $Qa) 
    (count->confidence 1)))
</span>

;;; Alternate implication direct introduction formula.  Inductive case,
;;; meaning the piece of evidence gets aggregated to another truth
;;; value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'direct-introduction-recursive-formula',[->,'Bool','TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: direct-introduction-recursive-formula 
  (-> Bool TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['direct-introduction-recursive-formula','False',['STV',PQs,PQc]],['inc-neg-count',['STV',PQs,PQc]]])
</span><span class="ansi38-255165000">(= 
  (direct-introduction-recursive-formula False 
    (STV $PQs $PQc)) 
  (inc-neg-count 
    (STV $PQs $PQc)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['direct-introduction-recursive-formula','True',['STV',PQs,PQc]],['inc-pos-count',['STV',PQs,PQc]]])
</span><span class="ansi38-255165000">(= 
  (direct-introduction-recursive-formula True 
    (STV $PQs $PQc)) 
  (inc-pos-count 
    (STV $PQs $PQc)))
</span>

    <--(8,retval('Empty'))
Last Result(3): <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[idi_axiom],['\x89\\x9E\',['\x86\\x92\',P,Q],['ETV','Empty',['STV',1,0]]]])
</span><span class="ansi38-255165000">(= 
  (idi_axiom) 
  ( 
    ( $P $Q) 
    (ETV Empty 
      (STV 1 0))))
</span>

;;; Recursive step (inductive rule):
;;;
;;; (p a)  patv
;;; (q a)  qatv
;;; pq  (ETV ev pqtv)
;;; a  ev
;;; 
;;; pq  (ETV (insert a ev) tv)
;;;
;;; where tv is calculated as defined in the idi_formula.
;;;
;;; IDI rule as a function
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[idi_induction,['\x89\\x9E\',[P,A],Patv],['\x89\\x9E\',[Q,A],Qatv],['\x89\\x9E\',['\x86\\x92\',P,Q],['ETV',Ev,Pqtv]],['\x88\\x89\',A,Ev]],['\x89\\x9E\',['\x86\\x92\',P,Q],['ETV',[insert,A,Ev],[idi_formula,Patv,Qatv,Pqtv]]]])
</span><span class="ansi38-255165000">(= 
  (idi_induction 
    ( 
      ($P $A) $Patv) 
    ( 
      ($Q $A) $Qatv) 
    ( 
      ( $P $Q) 
      (ETV $Ev $Pqtv)) 
    ( $A $Ev)) 
  ( 
    ( $P $Q) 
    (ETV 
      (insert $A $Ev) 
      (idi_formula $Patv $Qatv $Pqtv))))
</span>

;; Corresponding matching query of IDI rule
;;;; There is a bug with MeTTa interpreter in using let* for this matching query,
;; as it matches ($p $a), ($q $a) with (= (idi_induction_match $kb) ...) pattern.
;; Thus the interpreter gets in aninfinite loop. The solution given by Alexey is
;; to set Type (:  (-> Atom Atom Atom)), but using such Type causes the evaluations
;; inside the conclusion to don't get reduced. So, I am not using let* until gets fixed.
;;;;
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,idi_induction_match,[->,Kb,'Atom']])
</span><span class="ansi38-255165000">(: idi_induction_match 
  (-> $Kb Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[idi_induction_match,Kb],[match,Kb,[',',['\x89\\x9E\',[P,A],Patv],['\x89\\x9E\',[Q,A],Qatv],['\x89\\x9E\',['\x86\\x92\',P,Q],['ETV',Ev,Pqtv]],['\x88\\x89\',A,Ev]],[idi_induction,['\x89\\x9E\',[P,A],Patv],['\x89\\x9E\',[Q,A],Qatv],['\x89\\x9E\',['\x86\\x92\',P,Q],['ETV',Ev,Pqtv]],['\x88\\x89\',A,Ev]]]])
</span><span class="ansi38-255165000">(= 
  (idi_induction_match $Kb) 
  (match $Kb 
    (, 
      ( 
        ($P $A) $Patv) 
      ( 
        ($Q $A) $Qatv) 
      ( 
        ( $P $Q) 
        (ETV $Ev $Pqtv)) 
      ( $A $Ev)) 
    (idi_induction 
      ( 
        ($P $A) $Patv) 
      ( 
        ($Q $A) $Qatv) 
      ( 
        ( $P $Q) 
        (ETV $Ev $Pqtv)) 
      ( $A $Ev))))
</span>

    <--(0,retval('Empty'))
Last Result(4): <span class="ansi33">Empty

</span>;;; Premises
;;; Conclusion
<span class="ansi38-013099040">!(import! &self DeductionMatch.metta)

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','DeductionMatch.metta'],OUT).

</span>    -->(0,eval('&self',['import!','&self','DeductionMatch.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionMatch.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionMatch.metta')
;; Use IDI rule to infer P->Q based on the following,
;;; MeTTa port for deduction PLN rule
;;; using match
;;;
;;; ( P ptv)
;;; ( Q qtv)
;;; ( R rtv)
;;; ( ( P Q) tv1)
;;; ( ( Q R) tv2)
;;; 
;;; ( ( P R) TV)
;;;
;;; where ptv, qtv, rtv, tv1 and tv2 are truth values of the
;;; premises P, Q, R, ( P Q) and ( Q R) respectively.
;;; TV represents the resulting truth value of the conclusion.
;;; Import formula functions
<span class="ansi38-013099040">!(import! &self "../common/formula/DeductionFormula.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../common/formula/DeductionFormula.metta'],OUT).

</span>    -->(1,eval('&self',['import!','&self','../common/formula/DeductionFormula.metta'],RET),depth(0))
%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta:98 
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/formula/DeductionFormula.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/formula/DeductionFormula.metta')
;;;;;;;;;;;;;;;;;;;;;;
;;; Rule Definition ;;
;;;;;;;;;;;;;;;;;;;;;;
;;; Deduction rule represented as a function.
;;;
;;; P  PTV
;;; Q  QTV
;;; R  RTV
;;; P  Q  PQTV
;;; Q  R  RQTV
;;; 
;;; P  R  TV
;;; Formula and other functions used for the deduction rule
;;; Import modules
<span class="ansi38-013099040">!(import! &self "../truthvalue/TruthValue.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../truthvalue/TruthValue.metta'],OUT).

</span>    -->(2,eval('&self',['import!','&self','../truthvalue/TruthValue.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta')
;;; Truth value type definition
;;; Import modules
<span class="ansi38-013099040">!(import! &self "../Num.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../Num.metta'],OUT).

</span>    -->(3,eval('&self',['import!','&self','../Num.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta')
;;;;;;;;;;;
;;; Type ;;
;;;;;;;;;;;
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,X,Y],[if,[>,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,X,Y],[if,[<,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,X,L,U],[max,L,[min,U,X]]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,X],[if,[<,X,0],[*,-1,X],X]])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon]])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S',K]],[+,1,[fromNat,K]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, , for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  ( $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  ( Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',['S',X],['S',Y]],['',X,Y]])
</span><span class="ansi38-255165000">(= 
  ( 
    (S $X) 
    (S $Y)) 
  ( $X $Y))
</span>

;;; Overload  for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',X,Y],[<,X,Y]])
</span><span class="ansi38-255165000">(= 
  ( $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,N],[fromNat,[fromNumber,N]]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool',X],[<,0,X]])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than  as it is a type, not an operator.  Inhabitants of ( x y)
;;; are proofs that x  y == True.  For now  is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(:  
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['\x8D\\x83\','Z',['S',K]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    ( Z 
      (S $K))))
</span>

;;; If x  y then (S x)  (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['\x8D\\x83\',X,Y],['\x8D\\x83\',['S',X],['S',Y]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      ( $X $Y) 
      ( 
        (S $X) 
        (S $Y)))))
</span>

    <--(3,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'TruthValue','Type'])
</span><span class="ansi38-255165000">(: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;;
;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;
;;; Boolean TV constructor
;;; TODO: alternatively we could have (:  TruthValue) and (:  TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Bl',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">(: Bl 
  (-> Bool TruthValue))
</span>

;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Pr',[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">(: Pr 
  (-> Number TruthValue))
</span>

;;; Simple Truth Value.  A Second order probability TV constructor,
;;; i.e. probability and confidence.  The probability is in fact the
;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'STV',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">(: STV 
  (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;;
;;; Constants ;;
;;;;;;;;;;;;;;;;
;;; For now the underlying beta distributions have a Jeffreys prior,
;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-alpha',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-alpha 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-alpha'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-alpha) 0.5)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-beta',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-beta 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-beta'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-beta) 0.5)
</span>

;;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,lookahead,[->,'Number']])
</span><span class="ansi38-255165000">(: lookahead 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[lookahead],1.0])
</span><span class="ansi38-255165000">(= 
  (lookahead) 1.0)
</span>

;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'max-count',[->,'Number']])
</span><span class="ansi38-255165000">(: max-count 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['max-count'],1000000000.0])
</span><span class="ansi38-255165000">(= 
  (max-count) 1000000000.0)
</span>

;;;;;;;;;;;;;;
;;; Methods ;;
;;;;;;;;;;;;;;
;;; Convert count to confidence using the formula
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'count->confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: count->confidence 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['count->confidence',Cnt],[/,Cnt,[+,Cnt,[lookahead]]]])
</span><span class="ansi38-255165000">(= 
  (count->confidence $Cnt) 
  (/ $Cnt 
    (+ $Cnt 
      (lookahead))))
</span>

;;; Convert confidence to count using the formula
;;;
;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'confidence->count',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: confidence->count 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['confidence->count',Conf],[if,[approxEq,1.0,Conf,1.0e-9],['max-count'],[/,[*,Conf,[lookahead]],[-,1.0,Conf]]]])
</span><span class="ansi38-255165000">(= 
  (confidence->count $Conf) 
  (if 
    (approxEq 1.0 $Conf 1.0e-9) 
    (max-count) 
    (/ 
      (* $Conf 
        (lookahead)) 
      (- 1.0 $Conf))))
</span>

;;; Increment the negative count of a given truth value, by
;;; incrementing its total count without incrementing the positive
;;; count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-neg-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-neg-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-neg-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,Pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]]])
</span><span class="ansi38-255165000">(= 
  (inc-neg-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      (/ $Pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Increment the positive count of a given truth value, by
;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-pos-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-pos-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-pos-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_pos_cnt,[+,Pos_cnt,1]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,New_pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]]])
</span><span class="ansi38-255165000">(= 
  (inc-pos-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_pos_cnt 
        (+ $Pos_cnt 1)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      (/ $New_pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Return the first order probability mode of the second order
;;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mode,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mode 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Pr',Pr]],Pr])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['STV',Pr,_]],Pr])
</span><span class="ansi38-255165000">(= 
  (mode 
    (STV $Pr $_)) $Pr)
</span>

;;; Return the total count of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the count
;;; is assumed to be a very large number (cause +inf does not seem to
;;; be supported at the moment).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Bl',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Bl $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Pr',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Pr $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['STV',_,Conf]],['confidence->count',Conf]])
</span><span class="ansi38-255165000">(= 
  (count 
    (STV $_ $Conf)) 
  (confidence->count $Conf))
</span>

;;; Return the confidence of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, the formula to convert a count
;;; into confidence is as follows
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,confidence,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: confidence 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Bl',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Bl $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Pr',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Pr $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['STV',_,Conf]],Conf])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (STV $_ $Conf)) $Conf)
</span>

;;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'pos-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: pos-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['pos-count',Tv],[*,[mode,Tv],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (pos-count $Tv) 
  (* 
    (mode $Tv) 
    (count $Tv)))
</span>

;;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'neg-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: neg-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['neg-count',Tv],[*,[-,1,[mode,Tv]],[count,Tv]]])
</span><span class="ansi38-255165000">(= 
  (neg-count $Tv) 
  (* 
    (- 1 
      (mode $Tv)) 
    (count $Tv)))
</span>

;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-alpha',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-alpha 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-alpha',Tv],[+,['prior-alpha'],['pos-count',Tv]]])
</span><span class="ansi38-255165000">(= 
  (post-alpha $Tv) 
  (+ 
    (prior-alpha) 
    (pos-count $Tv)))
</span>

;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-beta',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-beta 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-beta',Tv],[+,['prior-beta'],['neg-count',Tv]]])
</span><span class="ansi38-255165000">(= 
  (post-beta $Tv) 
  (+ 
    (prior-beta) 
    (neg-count $Tv)))
</span>

;;; Return the first order probability mean of the second order
;;; distribution associated to a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mean,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mean 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Pr',Pr]],Pr])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['STV',Pr,Conf]],['let*',[[A,['post-alpha',['STV',Pr,Conf]]],[B,['post-beta',['STV',Pr,Conf]]]],[/,A,[+,A,B]]]])
</span><span class="ansi38-255165000">(= 
  (mean 
    (STV $Pr $Conf)) 
  (let* 
    ( ($A 
        (post-alpha 
          (STV $Pr $Conf))) 
      ($B 
        (post-beta 
          (STV $Pr $Conf)))) 
    (/ $A 
      (+ $A $B))))
</span>

    <--(2,retval('Empty'))
Last Result(2): <span class="ansi33">Empty

</span><span class="ansi38-013099040">!(import! &self "../Num.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../Num.metta'],OUT).

</span>    -->(4,eval('&self',['import!','&self','../Num.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta')
;; Consistency Conditions
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,X,Y],[if,[>,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,X,Y],[if,[<,X,Y],X,Y]])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,X,L,U],[max,L,[min,U,X]]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,X],[if,[<,X,0],[*,-1,X],X]])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon]])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S',K]],[+,1,[fromNat,K]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, , for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  ( $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  ( Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',['S',X],['S',Y]],['',X,Y]])
</span><span class="ansi38-255165000">(= 
  ( 
    (S $X) 
    (S $Y)) 
  ( $X $Y))
</span>

;;; Overload  for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(:  
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['',X,Y],[<,X,Y]])
</span><span class="ansi38-255165000">(= 
  ( $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,N],[fromNat,[fromNumber,N]]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool',X],[<,0,X]])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than  as it is a type, not an operator.  Inhabitants of ( x y)
;;; are proofs that x  y == True.  For now  is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(:  
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['\x8D\\x83\','Z',['S',K]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    ( Z 
      (S $K))))
</span>

;;; If x  y then (S x)  (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['\x8D\\x83\',X,Y],['\x8D\\x83\',['S',X],['S',Y]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      ( $X $Y) 
      ( 
        (S $X) 
        (S $Y)))))
</span>

    <--(4,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'smallest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">(: smallest-intersection-probability 
  (-> Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['smallest-intersection-probability',As,Bs],[clamp,[/,[-,[+,As,Bs],1],As],0,1]])
</span><span class="ansi38-255165000">(= 
  (smallest-intersection-probability $As $Bs) 
  (clamp 
    (/ 
      (- 
        (+ $As $Bs) 1) $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'largest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">(: largest-intersection-probability 
  (-> Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['largest-intersection-probability',As,Bs],[clamp,[/,Bs,As],0,1]])
</span><span class="ansi38-255165000">(= 
  (largest-intersection-probability $As $Bs) 
  (clamp 
    (/ $Bs $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'conditional-probability-consistency',[->,'Number','Number','Number','Bool']])
</span><span class="ansi38-255165000">(: conditional-probability-consistency 
  (-> Number Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['conditional-probability-consistency',As,Bs,ABs],[and,[<,0,As],[and,[<=,['smallest-intersection-probability',As,Bs],ABs],[<=,ABs,['largest-intersection-probability',As,Bs]]]]])
</span><span class="ansi38-255165000">(= 
  (conditional-probability-consistency $As $Bs $ABs) 
  (and 
    (< 0 $As) 
    (and 
      (<= 
        (smallest-intersection-probability $As $Bs) $ABs) 
      (<= $ABs 
        (largest-intersection-probability $As $Bs)))))
</span>

;;; Main Formula
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'simple-deduction-strength-formula',[->,'Number','Number','Number','Number','Number','Number']])
</span><span class="ansi38-255165000">(: simple-deduction-strength-formula 
  (-> Number Number Number Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['simple-deduction-strength-formula',As,Bs,Cs,ABs,BCs],[if,[and,['conditional-probability-consistency',As,Bs,ABs],['conditional-probability-consistency',Bs,Cs,BCs]],[if,[<,0.99,Bs],Cs,[+,[*,ABs,BCs],[/,[*,[-,1,ABs],[-,Cs,[*,Bs,BCs]]],[-,1,Bs]]]],0]])
</span><span class="ansi38-255165000">(= 
  (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
  (if 
    (and 
      (conditional-probability-consistency $As $Bs $ABs) 
      (conditional-probability-consistency $Bs $Cs $BCs)) 
    (if 
      (< 0.99 $Bs) $Cs 
      (+ 
        (* $ABs $BCs) 
        (/ 
          (* 
            (- 1 $ABs) 
            (- $Cs 
              (* $Bs $BCs))) 
          (- 1 $Bs)))) 0))
</span>

;;; Preconditions are met
;;; sB tends to 1
;;; otherwise
;;; Preconditions are not met
;;; Alternate deduction formula hardwired for STV to make it faster.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['deduction-formula',['STV',Ps,Pc],['STV',Qs,Qc],['STV',Rs,Rc],['STV',PQs,PQc],['STV',QRs,QRc]],[if,[and,['conditional-probability-consistency',Ps,Qs,PQs],['conditional-probability-consistency',Qs,Rs,QRs]],['STV',[if,[<,0.9999,Qs],Rs,[+,[*,PQs,QRs],[/,[*,[-,1,PQs],[-,Rs,[*,Qs,QRs]]],[-,1,Qs]]]],[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]],['STV',1,0]]])
</span><span class="ansi38-255165000">(= 
  (deduction-formula 
    (STV $Ps $Pc) 
    (STV $Qs $Qc) 
    (STV $Rs $Rc) 
    (STV $PQs $PQc) 
    (STV $QRs $QRc)) 
  (if 
    (and 
      (conditional-probability-consistency $Ps $Qs $PQs) 
      (conditional-probability-consistency $Qs $Rs $QRs)) 
    (STV 
      (if 
        (< 0.9999 $Qs) $Rs 
        (+ 
          (* $PQs $QRs) 
          (/ 
            (* 
              (- 1 $PQs) 
              (- $Rs 
                (* $Qs $QRs))) 
            (- 1 $Qs)))) 
      (min $Pc 
        (min $Qc 
          (min $Rc 
            (min $PQc $QRc))))) 
    (STV 1 0)))
</span>

    <--(1,retval('Empty'))
Last Result(2): <span class="ansi33">Empty

</span>;;; Preconditions are met
;; avoid division by 0
;;; Qs tends to 1
;;; Otherwise
;;; Preconditions are not met
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[deduction,['\x89\\x9E\',P,Ptv],['\x89\\x9E\',Q,Qtv],['\x89\\x9E\',R,Rtv],['\x89\\x9E\',['\x86\\x92\',P,Q],Pqtv],['\x89\\x9E\',['\x86\\x92\',Q,R],Qrtv]],['\x89\\x9E\',['\x86\\x92\',P,R],[ded_formula,Ptv,Qtv,Rtv,Pqtv,Qrtv]]])
</span><span class="ansi38-255165000">(= 
  (deduction 
    ( $P $Ptv) 
    ( $Q $Qtv) 
    ( $R $Rtv) 
    ( 
      ( $P $Q) $Pqtv) 
    ( 
      ( $Q $R) $Qrtv)) 
  ( 
    ( $P $R) 
    (ded_formula $Ptv $Qtv $Rtv $Pqtv $Qrtv)))
</span>

;;; Corresponding matching query of that rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,deduction_match,[->,Kb,'Atom']])
</span><span class="ansi38-255165000">(: deduction_match 
  (-> $Kb Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[deduction_match,Kb],['let*',[[Prem1,['\x89\\x9E\',P,Ptv]],[Prem2,['\x89\\x9E\',Q,Qtv]],[Prem3,['\x89\\x9E\',R,Rtv]],[Prem4,['\x89\\x9E\',['\x86\\x92\',P,Q],Pqtv]],[Prem5,['\x89\\x9E\',['\x86\\x92\',Q,R],Qrtv]]],[match,Kb,[',',Prem1,Prem2,Prem3,Prem4,Prem5],[deduction,Prem1,Prem2,Prem3,Prem4,Prem5]]]])
</span><span class="ansi38-255165000">(= 
  (deduction_match $Kb) 
  (let* 
    ( ($Prem1 
        ( $P $Ptv)) 
      ($Prem2 
        ( $Q $Qtv)) 
      ($Prem3 
        ( $R $Rtv)) 
      ($Prem4 
        ( 
          ( $P $Q) $Pqtv)) 
      ($Prem5 
        ( 
          ( $Q $R) $Qrtv))) 
    (match $Kb 
      (, $Prem1 $Prem2 $Prem3 $Prem4 $Prem5) 
      (deduction $Prem1 $Prem2 $Prem3 $Prem4 $Prem5))))
</span>

    <--(0,retval('Empty'))
Last Result(3): <span class="ansi33">Empty

</span>;;; Premises
;;; Conclusion
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',['\x89\\x9E\',['P',42],['Bl','True']])
</span><span class="ansi38-255165000">( 
  (P 42) 
  (Bl True))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',['\x89\\x9E\',['Q',42],['Bl','False']])
</span><span class="ansi38-255165000">( 
  (Q 42) 
  (Bl False))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',['\x88\\x89\',42,'Empty'])
</span><span class="ansi38-255165000">( 42 Empty)
</span>

;; Q->R is already in the atomspace
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',['\x89\\x9E\',['\x86\\x92\','Q','R'],['STV',1,0.5]])
</span><span class="ansi38-255165000">( 
  ( Q R) 
  (STV 1 0.5))
</span>

;; Predicates
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',['\x89\\x9E\','P',['STV',1,0.1]])
</span><span class="ansi38-255165000">( P 
  (STV 1 0.1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',['\x89\\x9E\','Q',['STV',1,0.5]])
</span><span class="ansi38-255165000">( Q 
  (STV 1 0.5))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',['\x89\\x9E\','R',['STV',1,0.1]])
</span><span class="ansi38-255165000">( R 
  (STV 1 0.1))
</span>

;; Matching query to do IDI and deduction rules
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(match &self 
  (, 
    ( $P $Ptv) 
    ( $Q $Qtv) 
    ( $R $Rtv) 
    ( 
      ($P $A) $Patv) 
    ( 
      ($Q $A) $Qatv) 
    ( $A $Ev) 
    ( 
      ( $Q $R) $Qrtv)) 
  (deduction 
    ( $P $Ptv) 
    ( $Q $Qtv) 
    ( $R $Rtv) 
    (idi_induction 
      ( 
        ($P $A) $Patv) 
      ( 
        ($Q $A) $Qatv) 
      (idi_axiom) 
      ( $A $Ev)) 
    ( 
      ( $Q $R) $Qrtv)))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (match &self 
    (, 
      ( $P $Ptv) 
      ( $Q $Qtv) 
      ( $R $Rtv) 
      ( 
        ($P $A) $Patv) 
      ( 
        ($Q $A) $Qatv) 
      ( $A $Ev) 
      ( 
        ( $Q $R) $Qrtv)) 
    (deduction 
      ( $P $Ptv) 
      ( $Q $Qtv) 
      ( $R $Rtv) 
      (idi_induction 
        ( 
          ($P $A) $Patv) 
        ( 
          ($Q $A) $Qatv) 
        (idi_axiom) 
        ( $A $Ev)) 
      ( 
        ( $Q $R) $Qrtv))) 
  ( (deduction 
      ( Q 
        (STV 1 0.5)) 
      ( Q 
        (STV 1 0.5)) 
      ( R 
        (STV 1 0.1)) 
      (idi_induction 
        ( 
          (Q 42) 
          (Bl False)) 
        ( 
          (Q 42) 
          (Bl False)) 
        (idi_axiom) 
        ( 42 Empty)) 
      ( 
        ( Q R) 
        (STV 1 0.5))) 
    (deduction 
      ( P 
        (STV 1 0.1)) 
      ( Q 
        (STV 1 0.5)) 
      ( R 
        (STV 1 0.1)) 
      (idi_induction 
        ( 
          (P 42) 
          (Bl True)) 
        ( 
          (Q 42) 
          (Bl False)) 
        (idi_axiom) 
        ( 42 Empty)) 
      ( 
        ( Q R) 
        (STV 1 0.5)))))

</span><span class="ansi38-250144246">; !(match &self (, ( $P $Ptv) ( $Q $Qtv) ( $R $Rtv) ( ($P $A) $Patv) ( ($Q $A) $Qatv) ( $A $Ev) ( ( $Q $R) $Qrtv)) (deduction ( $P $Ptv) ( $Q $Qtv) ( $R $Rtv) (idi_induction ( ($P $A) $Patv) ( ($Q $A) $Qatv) (idi_axiom) ( $A $Ev)) ( ( $Q $R) $Qrtv)))
</span><span class="ansi38-218112214">% DEBUG:   eval('&self',[match,'&self',[',',['\x89\\x9E\',P,Ptv],['\x89\\x9E\',Q,Qtv],['\x89\\x9E\',R,Rtv],['\x89\\x9E\',[P,A],Patv],['\x89\\x9E\',[Q,A],Qatv],['\x88\\x89\',A,Ev],['\x89\\x9E\',['\x86\\x92\',Q,R],Qrtv]],[deduction,['\x89\\x9E\',P,Ptv],['\x89\\x9E\',Q,Qtv],['\x89\\x9E\',R,Rtv],[idi_induction,['\x89\\x9E\',[P,A],Patv],['\x89\\x9E\',[Q,A],Qatv],[idi_axiom],['\x88\\x89\',A,Ev]],['\x89\\x9E\',['\x86\\x92\',Q,R],Qrtv]]],OUT).

</span>    -->(0,eval('&self',[assertEqualToResult,[match,'&self',[',',['\x89\\x9E\',_25906,_26190],['\x89\\x9E\',_26502,_26786],['\x89\\x9E\',_27098,_27382],['\x89\\x9E\',[_25906,_27982],_28266],['\x89\\x9E\',[_26502,_27982],_29152],['\x88\\x89\',_27982,_29750],['\x89\\x9E\',['\x86\\x92\',_26502,_27098],_30632]],[deduction,['\x89\\x9E\',_25906,_26190],['\x89\\x9E\',_26502,_26786],['\x89\\x9E\',_27098,_27382],[idi_induction,['\x89\\x9E\',[_25906,_27982],_28266],['\x89\\x9E\',[_26502,_27982],_29152],[idi_axiom],['\x88\\x89\',_27982,_29750]],['\x89\\x9E\',['\x86\\x92\',_26502,_27098],_30632]]],[[deduction,[,'Q',['STV',1,0.5]],[,'Q',['STV',1,0.5]],[,'R',['STV',1,0.1]],[idi_induction,[,['Q',42],['Bl','False']],[,['Q',42],['Bl','False']],[idi_axiom],[,42,'Empty']],[,[,'Q','R'],['STV',1,0.5]]],[deduction,[,'P',['STV',1,0.1]],[,'Q',['STV',1,0.5]],[,'R',['STV',1,0.1]],[idi_induction,[,['P',42],['Bl','True']],[,['Q',42],['Bl','False']],[idi_axiom],[,42,'Empty']],[,[,'Q','R'],['STV',1,0.5]]]]],RET),depth(0))
<h3 id="MATCH.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONMATCHTEST.01">;; MATCH.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONMATCHTEST.01</h3>
      -->(1,eval('&self',[match,'&self',[',',['\x89\\x9E\',_25906,_26190],['\x89\\x9E\',_26502,_26786],['\x89\\x9E\',_27098,_27382],['\x89\\x9E\',[_25906,_27982],_28266],['\x89\\x9E\',[_26502,_27982],_29152],['\x88\\x89\',_27982,_29750],['\x89\\x9E\',['\x86\\x92\',_26502,_27098],_30632]],[deduction,['\x89\\x9E\',_25906,_26190],['\x89\\x9E\',_26502,_26786],['\x89\\x9E\',_27098,_27382],[idi_induction,['\x89\\x9E\',[_25906,_27982],_28266],['\x89\\x9E\',[_26502,_27982],_29152],[idi_axiom],['\x88\\x89\',_27982,_29750]],['\x89\\x9E\',['\x86\\x92\',_26502,_27098],_30632]]],RET),depth(1))
          -->(2,eval('&self',['\x89\\x9E\','P',['STV',1,0.1]],RET),depth(3))
            -->(3,eval('&self',['STV',1,0.1],RET),depth(4))
                  -->(4,subst_args('&self',['STV',1,0.1],RET),depth(7))
            <--(3,retval(['STV',1,0.1]))
            -->(5,eval('&self',['STV',1,0.1],RET),depth(4))
                  -->(6,subst_args('&self',['STV',1,0.1],RET),depth(7))
            <--(5,retval(['STV',1,0.1]))
                -->(7,subst_args('&self',['\x89\\x9E\','P',['STV',1,0.1]],RET),depth(6))
                    -->(8,subst_args('&self',['STV',1,0.1],RET),depth(8))
                    -->(9,subst_args('&self',['STV',1,0.1],RET),depth(8))
          <--(2,retval(['\x89\\x9E\','P',['STV',1,0.1]]))
          -->(10,eval('&self',['\x89\\x9E\','Q',['STV',1,0.5]],RET),depth(3))
            -->(11,eval('&self',['STV',1,0.5],RET),depth(4))
                  -->(12,subst_args('&self',['STV',1,0.5],RET),depth(7))
            <--(11,retval(['STV',1,0.5]))
            -->(13,eval('&self',['STV',1,0.5],RET),depth(4))
                  -->(14,subst_args('&self',['STV',1,0.5],RET),depth(7))
            <--(13,retval(['STV',1,0.5]))
                -->(15,subst_args('&self',['\x89\\x9E\','Q',['STV',1,0.5]],RET),depth(6))
                    -->(16,subst_args('&self',['STV',1,0.5],RET),depth(8))
                    -->(17,subst_args('&self',['STV',1,0.5],RET),depth(8))
          <--(10,retval(['\x89\\x9E\','Q',['STV',1,0.5]]))
          -->(18,eval('&self',['\x89\\x9E\','R',['STV',1,0.1]],RET),depth(3))
            -->(19,eval('&self',['STV',1,0.1],RET),depth(4))
                  -->(20,subst_args('&self',['STV',1,0.1],RET),depth(7))
            <--(19,retval(['STV',1,0.1]))
            -->(21,eval('&self',['STV',1,0.1],RET),depth(4))
                  -->(22,subst_args('&self',['STV',1,0.1],RET),depth(7))
            <--(21,retval(['STV',1,0.1]))
                -->(23,subst_args('&self',['\x89\\x9E\','R',['STV',1,0.1]],RET),depth(6))
                    -->(24,subst_args('&self',['STV',1,0.1],RET),depth(8))
                    -->(25,subst_args('&self',['STV',1,0.1],RET),depth(8))
          <--(18,retval(['\x89\\x9E\','R',['STV',1,0.1]]))
          -->(26,eval('&self',[idi_induction,['\x89\\x9E\',['P',42],['Bl','True']],['\x89\\x9E\',['Q',42],['Bl','False']],[idi_axiom],['\x88\\x89\',42,'Empty']],RET),depth(3))
            -->(27,eval('&self',['\x89\\x9E\',['P',42],['Bl','True']],RET),depth(4))
              -->(28,eval('&self',['P',42],RET),depth(5))
                    -->(29,subst_args('&self',['P',42],RET),depth(8))
              <--(28,retval(['P',42]))
              -->(30,eval('&self',['Bl','True'],RET),depth(5))
                    -->(31,subst_args('&self',['Bl','True'],RET),depth(8))
              <--(30,retval(['Bl','True']))
              -->(32,eval('&self',['P',42],RET),depth(5))
                    -->(33,subst_args('&self',['P',42],RET),depth(8))
              <--(32,retval(['P',42]))
              -->(34,eval('&self',['Bl','True'],RET),depth(5))
                    -->(35,subst_args('&self',['Bl','True'],RET),depth(8))
              <--(34,retval(['Bl','True']))
                  -->(36,subst_args('&self',['\x89\\x9E\',['P',42],['Bl','True']],RET),depth(7))
                      -->(37,subst_args('&self',['P',42],RET),depth(9))
                      -->(38,subst_args('&self',['Bl','True'],RET),depth(9))
                      -->(39,subst_args('&self',['P',42],RET),depth(9))
                      -->(40,subst_args('&self',['Bl','True'],RET),depth(9))
            <--(27,retval(['\x89\\x9E\',['P',42],['Bl','True']]))
            -->(41,eval('&self',['\x89\\x9E\',['Q',42],['Bl','False']],RET),depth(4))
              -->(42,eval('&self',['Q',42],RET),depth(5))
                    -->(43,subst_args('&self',['Q',42],RET),depth(8))
              <--(42,retval(['Q',42]))
              -->(44,eval('&self',['Bl','False'],RET),depth(5))
                    -->(45,subst_args('&self',['Bl','False'],RET),depth(8))
              <--(44,retval(['Bl','False']))
              -->(46,eval('&self',['Q',42],RET),depth(5))
                    -->(47,subst_args('&self',['Q',42],RET),depth(8))
              <--(46,retval(['Q',42]))
              -->(48,eval('&self',['Bl','False'],RET),depth(5))
                    -->(49,subst_args('&self',['Bl','False'],RET),depth(8))
              <--(48,retval(['Bl','False']))
                  -->(50,subst_args('&self',['\x89\\x9E\',['Q',42],['Bl','False']],RET),depth(7))
                      -->(51,subst_args('&self',['Q',42],RET),depth(9))
                      -->(52,subst_args('&self',['Bl','False'],RET),depth(9))
                      -->(53,subst_args('&self',['Q',42],RET),depth(9))
                      -->(54,subst_args('&self',['Bl','False'],RET),depth(9))
            <--(41,retval(['\x89\\x9E\',['Q',42],['Bl','False']]))
            -->(55,eval('&self',[idi_axiom],RET),depth(4))
                -->(56,eval('&self',['\x86\\x92\',_109274,_109280],RET),depth(6))
                      -->(57,subst_args('&self',['\x86\\x92\',_109274,_109280],RET),depth(9))
                <--(56,retval(['\x86\\x92\',_110998,_111004]))
                -->(58,eval('&self',['ETV','Empty',['STV',1,0]],RET),depth(6))
                  -->(59,eval('&self',['STV',1,0],RET),depth(7))
                  <--(59,retval(['STV',1,0]))
                  -->(61,eval('&self',['STV',1,0],RET),depth(7))
                  <--(61,retval(['STV',1,0]))
                      -->(63,subst_args('&self',['ETV','Empty',['STV',1,0]],RET),depth(9))
                <--(58,retval(['ETV','Empty',['STV',1,0]]))
                -->(66,eval('&self',['\x86\\x92\',_109274,_109280],RET),depth(6))
                      -->(67,subst_args('&self',['\x86\\x92\',_109274,_109280],RET),depth(9))
                <--(66,retval(['\x86\\x92\',_118684,_118690]))
                -->(68,eval('&self',['ETV','Empty',['STV',1,0]],RET),depth(6))
                  -->(69,eval('&self',['STV',1,0],RET),depth(7))
                  <--(69,retval(['STV',1,0]))
                  -->(71,eval('&self',['STV',1,0],RET),depth(7))
                  <--(71,retval(['STV',1,0]))
                      -->(73,subst_args('&self',['ETV','Empty',['STV',1,0]],RET),depth(9))
                <--(68,retval(['ETV','Empty',['STV',1,0]]))
                    -->(76,subst_args('&self',['\x89\\x9E\',['\x86\\x92\',_109274,_109280],['ETV','Empty',['STV',1,0]]],RET),depth(8))
                  -->(85,subst_args('&self',['\x89\\x9E\',['\x86\\x92\',_109274,_109280],['ETV','Empty',['STV',1,0]]],RET),depth(7))
                      -->(86,subst_args('&self',['\x86\\x92\',_10656,_10658],RET),depth(9))
                      -->(87,subst_args('&self',['ETV','Empty',['STV',1,0]],RET),depth(9))
                      -->(90,subst_args('&self',['\x86\\x92\',_10656,_10658],RET),depth(9))
                      -->(91,subst_args('&self',['ETV','Empty',['STV',1,0]],RET),depth(9))
            -->(94,eval('&self',['\x88\\x89\',42,'Empty'],RET),depth(4))
                  -->(95,subst_args('&self',['\x88\\x89\',42,'Empty'],RET),depth(7))
            <--(94,retval(['\x88\\x89\',42,'Empty']))
                -->(96,eval('&self',['\x86\\x92\','P','Q'],RET),depth(6))
                      -->(97,subst_args('&self',['\x86\\x92\','P','Q'],RET),depth(9))
                <--(96,retval(['\x86\\x92\','P','Q']))
                -->(98,eval('&self',['ETV',[insert,42,'Empty'],[idi_formula,['Bl','True'],['Bl','False'],['STV',1,0]]],RET),depth(6))
                  -->(99,eval('&self',[insert,42,'Empty'],RET),depth(7))
                  <--(99,retval([insert,42,'Empty']))
; Switched off tracing. For a longer trace: !(pragma! trace-length 101)
                <--(98,retval(['ETV',[insert,42,'Empty'],[idi_formula,['Bl','True'],['Bl','False'],['STV',1,0]]]))
            <--(55,retval(['\x89\\x9E\',['\x86\\x92\',_16326,_16332],['ETV','Empty',['STV',1,0]]]))
          <--(26,retval(['\x89\\x9E\',['\x86\\x92\','P','Q'],['ETV',[insert,42,'Empty'],[idi_formula,['Bl','True'],['Bl','False'],['STV',1,0]]]]))
      <--(1,retval(['\x89\\x9E\',['\x86\\x92\','Q','R'],[ded_formula,['STV',1,0.5],['STV',1,0.5],['STV',1,0.1],['ETV',[insert,42,'Empty'],[idi_formula,['Bl','False'],['Bl','False'],['STV',1,0]]],['STV',1,0.5]]]))
; 
; EVAL TEST
; took 0.129 secs. (128.51 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    ( ( 
        ( P R) 
        (ded_formula 
          (STV 1 0.1) 
          (STV 1 0.5) 
          (STV 1 0.1) 
          (ETV 
            (insert 42 Empty) 
            (idi_formula 
              (Bl True) 
              (Bl False) 
              (STV 1 0))) 
          (STV 1 0.5))) 
      ( 
        ( Q R) 
        (ded_formula 
          (STV 1 0.5) 
          (STV 1 0.5) 
          (STV 1 0.1) 
          (ETV 
            (insert 42 Empty) 
            (idi_formula 
              (Bl False) 
              (Bl False) 
              (STV 1 0))) 
          (STV 1 0.5)))) 
    ( (deduction 
        ( P 
          (STV 1 0.1)) 
        ( Q 
          (STV 1 0.5)) 
        ( R 
          (STV 1 0.1)) 
        (idi_induction 
          ( 
            (P 42) 
            (Bl True)) 
          ( 
            (Q 42) 
            (Bl False)) 
          (idi_axiom) 
          ( 42 Empty)) 
        ( 
          ( Q R) 
          (STV 1 0.5))) 
      (deduction 
        ( Q 
          (STV 1 0.5)) 
        ( Q 
          (STV 1 0.5)) 
        ( R 
          (STV 1 0.1)) 
        (idi_induction 
          ( 
            (Q 42) 
            (Bl False)) 
          ( 
            (Q 42) 
            (Bl False)) 
          (idi_axiom) 
          ( 42 Empty)) 
        ( 
          ( Q R) 
          (STV 1 0.5))))))
</span>NDet Result(1): <span class="ansi33">
(got 
  ( ( 
      ( P R) 
      (ded_formula 
        (STV 1 0.1) 
        (STV 1 0.5) 
        (STV 1 0.1) 
        (ETV 
          (insert 42 Empty) 
          (idi_formula 
            (Bl True) 
            (Bl False) 
            (STV 1 0))) 
        (STV 1 0.5))) 
    ( 
      ( Q R) 
      (ded_formula 
        (STV 1 0.5) 
        (STV 1 0.5) 
        (STV 1 0.1) 
        (ETV 
          (insert 42 Empty) 
          (idi_formula 
            (Bl False) 
            (Bl False) 
            (STV 1 0))) 
        (STV 1 0.5)))) expected 
  ( (deduction 
      ( P 
        (STV 1 0.1)) 
      ( Q 
        (STV 1 0.5)) 
      ( R 
        (STV 1 0.1)) 
      (idi_induction 
        ( 
          (P 42) 
          (Bl True)) 
        ( 
          (Q 42) 
          (Bl False)) 
        ( 
          ( $_9138 $_9140) 
          (ETV Empty 
            (STV 1 0))) 
        ( 42 Empty)) 
      ( 
        ( Q R) 
        (STV 1 0.5))) 
    (deduction 
      ( Q 
        (STV 1 0.5)) 
      ( Q 
        (STV 1 0.5)) 
      ( R 
        (STV 1 0.1)) 
      (idi_induction 
        ( 
          (Q 42) 
          (Bl False)) 
        ( 
          (Q 42) 
          (Bl False)) 
        ( 
          ( $_9848 $_9850) 
          (ETV Empty 
            (STV 1 0))) 
        ( 42 Empty)) 
      ( 
        ( Q R) 
        (STV 1 0.5)))))

</span>    <--(0,retval([got,[['\x89\\x9E\',['\x86\\x92\','P','R'],[ded_formula,['STV',1,0.1],['STV',1,0.5],['STV',1,0.1],['ETV',[insert,42,'Empty'],[idi_formula,['Bl','True'],['Bl','False'],['STV',1,0]]],['STV',1,0.5]]],['\x89\\x9E\',['\x86\\x92\','Q','R'],[ded_formula,['STV',1,0.5],['STV',1,0.5],['STV',1,0.1],['ETV',[insert,42,'Empty'],[idi_formula,['Bl','False'],['Bl','False'],['STV',1,0]]],['STV',1,0.5]]]],expected,[[deduction,[,'P',['STV',1,0.1]],[,'Q',['STV',1,0.5]],[,'R',['STV',1,0.1]],[idi_induction,[,['P',42],['Bl','True']],[,['Q',42],['Bl','False']],['\x89\\x9E\',['\x86\\x92\',_74126,_74132],['ETV','Empty',['STV',1,0]]],[,42,'Empty']],[,[,'Q','R'],['STV',1,0.5]]],[deduction,[,'Q',['STV',1,0.5]],[,'Q',['STV',1,0.5]],[,'R',['STV',1,0.1]],[idi_induction,[,['Q',42],['Bl','False']],[,['Q',42],['Bl','False']],['\x89\\x9E\',['\x86\\x92\',_74534,_74540],['ETV','Empty',['STV',1,0]]],[,42,'Empty']],[,[,'Q','R'],['STV',1,0.5]]]]]))
<span class="ansi32">% 6,578,949 inferences, 5.341 CPU in 5.341 seconds (100% CPU, 1231734 Lips)
</span> (= "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 0
</span><span class="ansi31">Failures: 1
</span><br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE_20231212_0611_2278258.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/match/DeductionImplicationDirectIntroductionMatchTest.metta.html" )

</pre>
</body>

</html>
